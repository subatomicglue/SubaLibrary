AWSTemplateFormatVersion: '2010-09-09'
Description: Create an S3 Bucket with Cloudfront for hosting static HTML files.

Parameters:
  S3BucketName:
    Description: "S3 bucket name"
    Type: String
  DomainName:
    Description: "primary domain name"
    Type: String
  DomainName2:
    Description: "alternative domain name"
    Type: String
  EditableHostname:
    Description: "The Editable Hostname (could be www)"
    Type: String
  StaticHostnameForTesting:
    Description: "Static Hostname For Testing (e.g. private)"
    Type: String

Resources:
  S3Bucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Ref S3BucketName
      AccessControl: Private

  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Description: "origin access control(OAC) for allowing cloudfront to access S3 bucket"
        Name: static-hosting-OAC
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  # Set up a Redirect from DomainName2 to DomainName, so that SEO isn't split (which would result in SEO penalties)
  RedirectAllAliasesFunction:
    Type: AWS::CloudFront::Function
    Properties:
      Name: RedirectAllAliasesToCanonical
      FunctionConfig:
        Comment: !Sub "Redirect all subdomains of ${DomainName2} to canonical ${DomainName}"
        Runtime: cloudfront-js-1.0
      AutoPublish: true
      FunctionCode:
        !Sub |
          function handler(event) {
            var request = event.request;
            var host = request.headers['host'].value.toLowerCase();

            var canonicalRoot = "${DomainName}".toLowerCase();   // e.g., example.com
            var alternates = ["${DomainName2}".toLowerCase()];   // e.g., exam-ple.com

            // Normalize any //'s to /, just in case
            request.uri = request.uri.replace(/\/+/g, "/");

            // Already on canonical domain....
            // Apply rule rewrites.
            if (host.endsWith(canonicalRoot)) {
              // Define custom redirect/rewrite rules
              var redirect_rules = {
                "/wiki/view/index.html": "/wiki/view/index",
                "/wiki/view/": "/wiki/view/index",
                "/wiki/view": "/wiki/view/index",
                "/wiki/index.html": "/wiki/view/index",
                "/wiki/index": "/wiki/view/index",
                "/wiki/": "/wiki/view/index",
                "/wiki": "/wiki/view/index",
                "/index.html": "/wiki/view/index",
                "/index": "/wiki/view/index",
                "/": "/wiki/view/index",
                "": "/wiki/view/index"   // CloudFront request URIs are always prefixed with /, so "" will likely never occur
              };

              // Apply custom rules
              if (redirect_rules[request.uri]) {
                request.uri = redirect_rules[request.uri];
              }

              // redirect */ to */index
              if (request.uri.endsWith('/')) {
                request.uri += 'index';
              }
              return request;
            }

            // Check if host matches any alternate domain
            var matchedAlternate = alternates.find(function(a) {
              return host.endsWith(a);
            });

            if (!matchedAlternate) {
              // Host is not canonical or known alternate, leave it alone
              return request;
            }

            // Extract subdomain (anything before the alternate root)
            var subdomain = host.slice(0, host.length - matchedAlternate.length);
            if (subdomain.endsWith('.')) subdomain = subdomain.slice(0, -1);

            var newHost = subdomain ? (subdomain + '.' + canonicalRoot) : canonicalRoot;

            // Build query string safely
            var queryString = "";
            if (Object.keys(request.querystring).length > 0) {
              for (var param in request.querystring) {
                  if (request.querystring[param].value !== undefined) {
                      queryString += encodeURIComponent(param) + '=' + encodeURIComponent(request.querystring[param].value) + '&';
                  } else {
                      queryString += encodeURIComponent(param) + '&'; // For parameters without a value
                  }
              }
              // Remove trailing ampersand
              queryString = queryString.slice(0, -1);
              queryString = '?' + queryString;
            }

            return {
              statusCode: 302,
              statusDescription: 'Moved Temporarily',
              //statusCode: 301,
              //statusDescription: 'Moved Permanently',
              headers: {
                'location': { value: 'https://' + newHost + request.uri + queryString }
              }
            };
          }

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    DependsOn:
      - RedirectAllAliasesFunction
      - S3Bucket
      - SearchLambdaFunctionURL
      - SearchApi
    Properties:
      DistributionConfig:
        Origins:
          # S3 bucket serving static HTML files:
          - DomainName: !Sub "${S3BucketName}.s3.${AWS::Region}.amazonaws.com"
            Id: static-hosting
            S3OriginConfig:
              OriginAccessIdentity: ""
            OriginAccessControlId: !GetAtt CloudFrontOriginAccessControl.Id
          # Expose /search-testing
          - DomainName: !Sub "${SearchApi}.execute-api.${AWS::Region}.amazonaws.com"
            Id: search-testing
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
        Enabled: "true"
        DefaultRootObject: index.html
        CustomErrorResponses:
          - ErrorCode: 404
            ResponseCode: 404
            ResponsePagePath: /notfound.html
          - ErrorCode: 403
            ResponseCode: 403
            ResponsePagePath: /forbidden.html
        HttpVersion: http2
        Aliases:
          - !Sub "${DomainName2}"
          - !Sub "${DomainName}"
          - !Sub "${EditableHostname}.${DomainName2}"
          - !Sub "${EditableHostname}.${DomainName}"
          - !Sub "www.${DomainName2}"
          - !Sub "www.${DomainName}"
          - !Sub "${StaticHostnameForTesting}.${DomainName2}"
          - !Sub "${StaticHostnameForTesting}.${DomainName}"
        ViewerCertificate:
          AcmCertificateArn: "arn:aws:acm:us-east-1:244726690758:certificate/8ada54ac-0797-4894-9e7a-5e4d356e005f"
          MinimumProtocolVersion: TLSv1.2_2021
          SslSupportMethod: sni-only

        # default
        DefaultCacheBehavior:
          AllowedMethods:
            - HEAD         # level 1
            - GET          # level 1  - when modifying, you must match the entire level set...
            - OPTIONS      # level 2
            - PUT          # level 3
            - POST         # level 3
            - PATCH        # level 3
            - DELETE       # level 3
          Compress: true
          TargetOriginId: static-hosting
          ForwardedValues:
            QueryString: "false"
            Cookies:
              Forward: none
          ViewerProtocolPolicy: redirect-to-https
          CachePolicyId: !Ref MyCachePolicy
          ResponseHeadersPolicyId: !Ref MyResponseHeadersPolicy
          FunctionAssociations:
            - EventType: viewer-request
              FunctionARN: !GetAtt RedirectAllAliasesFunction.FunctionARN

        CacheBehaviors:
          # Expose Lambda REST Endpoint: /search-testing
          - PathPattern: /search-testing                         # for additional subpaths, use * to allow anything after 
            TargetOriginId: search-testing
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods:
              - HEAD         # level 1
              - GET          # level 1  - when modifying, you must match the entire level set...
              - OPTIONS      # level 2
              - PUT          # level 3
              - POST         # level 3
              - PATCH        # level 3
              - DELETE       # level 3
            Compress: true
            ForwardedValues:
              QueryString: true                                  # allow ?searchterm=textgoeshere
              Cookies:
                Forward: none

  MyCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        Name: CachePolicy
        Comment: Configures caching behavior
        DefaultTTL: 86400                # Default time-to-live (24 hours)
        MaxTTL: 31536000                # Maximum time-to-live (1 year)
        MinTTL: 0                       # Minimum time-to-live (no forced caching)
        ParametersInCacheKeyAndForwardedToOrigin:
          EnableAcceptEncodingGzip: true
          EnableAcceptEncodingBrotli: true
          HeadersConfig:
            HeaderBehavior: none         # No custom headers forwarded
          CookiesConfig:
            CookieBehavior: none         # No cookies forwarded
          QueryStringsConfig:
            QueryStringBehavior: none    # No query strings forwarded

  MyResponseHeadersPolicy:
    Type: AWS::CloudFront::ResponseHeadersPolicy
    Properties:
      ResponseHeadersPolicyConfig:
        Name: ReferrerPolicyHeaderPolicy
        Comment: Adds security headers including Referrer-Policy
        CorsConfig:
          AccessControlAllowOrigins:
            Items:
              - !Sub "${DomainName2}"
              - !Sub "${DomainName}"
              - !Sub "${EditableHostname}.${DomainName2}"
              - !Sub "${EditableHostname}.${DomainName}"
              - !Sub "www.${DomainName2}"
              - !Sub "www.${DomainName}"
              - !Sub "${StaticHostnameForTesting}.${DomainName2}"
              - !Sub "${StaticHostnameForTesting}.${DomainName}"
          AccessControlAllowHeaders:
            Items:
              - "*"
          AccessControlAllowMethods:
            Items:
              - HEAD         # level 1
              - GET          # level 1  - when modifying, you must match the entire level set...
              - OPTIONS      # level 2
              - PUT          # level 3
              - POST         # level 3
              - PATCH        # level 3
              - DELETE       # level 3
          AccessControlAllowCredentials: false   # or true, if you need cookies/Authorization headers
          OriginOverride: true
        SecurityHeadersConfig:
          ReferrerPolicy:
            Override: true
            ReferrerPolicy: strict-origin-when-cross-origin

  BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Sub "${S3BucketName}"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "cloudfront.amazonaws.com"
            Action: "s3:GetObject"
            Resource: !Sub "arn:aws:s3:::${S3BucketName}/*"
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub "arn:aws:cloudfront::244726690758:distribution/${CloudFrontDistribution}"

  # API Gateway -
  SearchApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: SearchApi
      ProtocolType: HTTP

  SearchApiIntegration:
    Type: AWS::ApiGatewayV2::Integration
    DependsOn:
      - SearchLambdaFunction
      - SearchApi
    Properties:
      ApiId: !Ref SearchApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SearchLambdaFunction.Arn}/invocations"
      PayloadFormatVersion: "2.0"

  SearchApiRoute:
    Type: AWS::ApiGatewayV2::Route
    DependsOn:
      - SearchApi
      - SearchApiIntegration
    Properties:
      ApiId: !Ref SearchApi
      RouteKey: "ANY /search-testing"
      Target: !Sub "integrations/${SearchApiIntegration}"

  SearchApiStage:
    Type: AWS::ApiGatewayV2::Stage
    DependsOn:
      - SearchApi
    Properties:
      ApiId: !Ref SearchApi
      StageName: "$default"
      AutoDeploy: true

  SearchLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - SearchLambdaFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SearchLambdaFunction
      Principal: apigateway.amazonaws.com

  SearchLambdaFunctionUrlInvokePermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - SearchLambdaFunction
      - SearchLambdaFunctionURL
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !Ref SearchLambdaFunction
      Principal: "*"
      FunctionUrlAuthType: NONE

  SearchLambdaFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - SearchLambdaFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SearchLambdaFunction
      Principal: "*"


  # 1. VPC for Lambda + EFS
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true

  Subnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [0, !GetAZs '']

  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Lambda to EFS
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 2049
          ToPort: 2049
          CidrIp: 10.0.0.0/16

  # 2. EFS FileSystem
  EFSFileSystem:
    Type: AWS::EFS::FileSystem
    Properties:
      Encrypted: true
      FileSystemTags:
        - Key: Name
          Value: search-efs
      PerformanceMode: generalPurpose
      LifecyclePolicies:
        - TransitionToIA: AFTER_30_DAYS

  EFSMountTarget:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref EFSFileSystem
      SubnetId: !Ref Subnet
      SecurityGroups: [!Ref SecurityGroup]

  # 3. Lambda Execution Role (S3: RO | EFS: RW)
  LambdaRolexS3ROxEFSRW:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SearchBucketReadOnlyAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${S3BucketName}"
                  - !Sub "arn:aws:s3:::${S3BucketName}/*"
        - PolicyName: EFSAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - elasticfilesystem:ClientMount
                  - elasticfilesystem:ClientWrite
                  - elasticfilesystem:ClientRootAccess
                Resource: !GetAtt EFSFileSystem.Arn
        - PolicyName: LambdaVPCAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                  - ec2:AssignPrivateIpAddresses
                  - ec2:UnassignPrivateIpAddresses
                Resource: "*"

  AuthEFSAcessPoint: # todo:    (will be used later for auth)
    Type: AWS::EFS::AccessPoint
    Properties:
      FileSystemId: !Ref EFSFileSystem
      PosixUser:
        Gid: 1000
        Uid: 1000
      RootDirectory:
        CreationInfo:
          OwnerGid: 1000
          OwnerUid: 1000
          Permissions: "750"
        Path: /auth   # expose only the auth data on the EFS volume

  SearchEFSAcessPoint:
    Type: AWS::EFS::AccessPoint
    Properties:
      FileSystemId: !Ref EFSFileSystem
      PosixUser:
        Gid: 1000
        Uid: 1000
      RootDirectory:
        CreationInfo:
          OwnerGid: 1000
          OwnerUid: 1000
          Permissions: "750"
        Path: /search   # expose only the search data on the EFS volume

  # 4. Lambda Function
  SearchLambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn: 
      - EFSMountTarget   # ensures the mount target is created first
    Properties:
      FunctionName: SearchLambdaFunction
      Handler: index.handler
      Runtime: nodejs18.x
      Role: !GetAtt LambdaRolexS3ROxEFSRW.Arn
      Timeout: 30
      MemorySize: 1024
      FileSystemConfigs:
        - Arn: !GetAtt SearchEFSAcessPoint.Arn
          LocalMountPath: /mnt/efs
      VpcConfig:
        SubnetIds:
          - !Ref Subnet
        SecurityGroupIds:
          - !Ref SecurityGroup
      Code:
        ZipFile: |
          exports.handler = async function(event) {
            const searchTerm = event.queryStringParameters?.searchterm || "";
            return {
              statusCode: 200,
              headers: { 'Content-Type': 'text/plain' },
              body: "You searched for: " + searchTerm
            };
          }
      # Code:
      #   ZipFile: |
      #     const fs = require('fs');

      #     exports.handler = async function(event) {
      #       let files;
      #       try {
      #         files = fs.readdirSync('/mnt/efs');
      #       } catch (err) {
      #         files = [`EFS not mounted: ${err.message}`];
      #       }

      #       return {
      #         statusCode: 200,
      #         headers: { 'Content-Type': 'application/json' },
      #         body: JSON.stringify({
      #           msg: "Hello from Lambda",
      #           path: event.rawPath || event.path || "/",
      #           efsListing: files
      #         })
      #       };
      #     };
      # Code:
      #   ZipFile: |
      #     const fs = require('fs')
      #     const AWS = require('aws-sdk')
      #     const s3 = new AWS.S3()
      #     const SEARCH_BUCKET = process.env.SEARCH_BUCKET
      #     const SEARCH_KEY = process.env.SEARCH_KEY
      #     const EFS_PATH = '/mnt/efs/search_index.json'

      #     exports.handler = async function(event) {
      #       // Check if file exists in EFS
      #       let copyNeeded = true
      #       try {
      #         const stats = fs.statSync(EFS_PATH)
      #         copyNeeded = false
      #       } catch {}

      #       if (copyNeeded) {
      #         const data = await s3.getObject({Bucket: SEARCH_BUCKET, Key: SEARCH_KEY}).promise()
      #         fs.writeFileSync(EFS_PATH, data.Body)
      #       }

      #       return {
      #         statusCode: 200,
      #         headers: {'Content-Type': 'text/plain'},
      #         body: fs.readFileSync(EFS_PATH, 'utf8')
      #       }
      #     }
      Environment:
        Variables:
          SEARCH_BUCKET: !Sub "${S3BucketName}"
          SEARCH_KEY: search_index.json

  # 5. Lambda Function URL
  SearchLambdaFunctionURL:
    Type: AWS::Lambda::Url
    DependsOn:
      - SearchLambdaFunction
    Properties:
      AuthType: NONE
      TargetFunctionArn: !Ref SearchLambdaFunction

Outputs:
  S3BucketName:
    Description: "The S3 bucket name"
    Value:
      Ref: S3Bucket
  OriginAccessControl:
    Value:
      Ref: CloudFrontOriginAccessControl
  CloudFrontDist:
    Value:
      Ref: CloudFrontDistribution
  # LambdaFunctionURL:
  #   Description: "Public URL of the Search Lambda"
  #   Value: !GetAtt SearchLambdaFunctionURL.FunctionUrl
  LambdaFunctionURL:
    Description: "Public URL of the Search Lambda"
    Value: !Sub "${SearchApi}.execute-api.${AWS::Region}.amazonaws.com"

