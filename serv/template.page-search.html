<script>
  /////////////////////////////////////////
  // Mark search terms and scroll logic
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function parseSearchTerms(term) {
    if (!term) return [];
    return term
      .split(',')
      .map(part => {
        const trimmed = part.trim();
        if (!trimmed) return null;
        const hasQuotes = trimmed.length >= 2 && trimmed.startsWith('"') && trimmed.endsWith('"');
        return hasQuotes ? trimmed.slice(1, -1) : trimmed;
      })
      .filter(Boolean);
  }

  function markupSearchTerms(term) {
    const terms = parseSearchTerms(term);
    if (terms.length === 0) return;

    const searchRegex = new RegExp(terms.map(escapeRegex).join('|'), 'gi');
    const container = document.getElementById('the-scroll-page');
    if (!container) return;

    clearMarks();

    // Get all text nodes
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
    const textNodes = [];
    let node;
    while ((node = walker.nextNode())) {
      if (node.parentNode && !['SCRIPT', 'STYLE'].includes(node.parentNode.tagName)) {
        textNodes.push(node);
      }
    }

    // Replace matches with <mark>
    textNodes.forEach(textNode => {
      const replaced = textNode.nodeValue.replace(searchRegex, match => `<mark>${match}</mark>`);
      if (replaced !== textNode.nodeValue) {
        const span = document.createElement('span');
        span.innerHTML = replaced;
        textNode.parentNode.replaceChild(span, textNode);
      }
    });
  }

  function saveModePreference() {
    localStorage.setItem( "search-mode", document.getElementById('search-mode').innerHTML )
  }
  function loadModePreference() {
    document.getElementById('search-mode').innerHTML = localStorage.getItem( "search-mode" ) ? localStorage.getItem( "search-mode" ) : search_mode_init_text
  }

  function getSearchTermFromURL() {
    const url = new URL(window.location.href);
    const params = new URLSearchParams(url.search);
    return params.get('searchterm') || '';
  }

  // Navigation logic
  let currentIndex = 0;

  function getNavOffset() {
    const style = getComputedStyle(document.documentElement);
    const value = parseFloat(style.getPropertyValue('--page-title-height'));
    return Number.isFinite(value) ? value : 0;
  }

  function scrollElementWithNavOffset(element, behavior = 'smooth') {
    if (!element) return;
    const navOffset = getNavOffset();
    const rect = element.getBoundingClientRect();
    const absoluteTop = window.scrollY + rect.top;
    window.scrollTo({
      top: absoluteTop - navOffset,
      left: window.scrollX,
      behavior
    });
  }

  function scrollToMark(index) {
    const marks = document.querySelectorAll('mark');

    if (marks.length === 0) return;

    // disable "goto next/prev mark" wrap-around.
    //if (index < 0 || index >= marks.length) return;

    currentIndex = ((index % marks.length) + marks.length) % marks.length;
    scrollElementWithNavOffset(marks[currentIndex]);

    // set the style on the marks
    let counter = 0;
    marks.forEach(mark => {
      if (counter++ === currentIndex)
        mark.className = 'selected';
      else
        mark.removeAttribute('class');
    });

    updateCounterDisplay();
  }

  function isSearching() {
    const controlDiv = document.getElementById('searchcontrol');
    return controlDiv.style.display != 'none'
  }
  function isSearchModeGlobal() {
    const searchMode = document.getElementById('search-mode')
    return searchMode.innerHTML == search_mode_global_text
  }
  function isSearchModeLocal() {
    const searchMode = document.getElementById('search-mode')
    return searchMode.innerHTML == search_mode_local_text
  }

  function updateCounterDisplay() {
    const marks = document.querySelectorAll('mark');
    const counter = document.getElementById('mark-counter');
    if (counter) {
      if (marks.length === 0) {
        counter.textContent = '0/0';
      } else {
        counter.textContent = `${currentIndex + 1}/${marks.length}`;
      }
    }
    updateSearchInstanceInURL(marks.length === 0 ? null : (currentIndex + 1));
  }

  function nextMark() {
    const marks = document.querySelectorAll('mark');
    //if (currentIndex < (marks.length - 1)) {
      scrollToMark(currentIndex + 1);
    //}
  }

  function prevMark() {
    //if (currentIndex > 0) {
      scrollToMark(currentIndex - 1);
    //}
  }

  function clearMarks() {
    const container = document.getElementById('the-scroll-page');
    if (!container) return;
    const oldMarks = container.querySelectorAll('mark');

    oldMarks.forEach(mark => {
      const prevNode = mark.previousSibling;
      const nextNode = mark.nextSibling;
      
      const textContent = mark.textContent;

      let combinedText = textContent;
      
      if (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
        combinedText = prevNode.textContent + combinedText;
        prevNode.remove();
      }

      if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
        combinedText += nextNode.textContent;
        nextNode.remove();
      }

      const textNode = document.createTextNode(combinedText);
      mark.replaceWith(textNode);
    });
  }

  // Helper to clear the searchterm from URL without reloading
  function clearSearchTermFromURL() {
    updateSearchTermInURL('')
  }

  function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        func.apply(this, args); // Call the function with the provided arguments
      }, delay);
    };
  }

  function updateSearchTermInURL(term) {
    const url = new URL(window.location.href);
    if (term === '') {
      url.searchParams.delete('searchterm');
      url.searchParams.delete('searchinstance');
      window.history.pushState({}, document.title, url.toString());
    } else {
      url.searchParams.set('searchterm', term);
      window.history.replaceState({}, document.title, url.toString());
    }
  }
  const debouncedUpdateSearchTermInURL = debounce(updateSearchTermInURL, 100);

  function getSearchInstanceFromURL() {
    const url = new URL(window.location.href);
    const value = parseInt(url.searchParams.get('searchinstance'), 10);
    if (!Number.isFinite(value) || value <= 1) return 0;
    return value - 1;
  }

  function updateSearchInstanceInURL(instance) {
    const url = new URL(window.location.href);
    if (!instance || instance <= 1) {
      url.searchParams.delete('searchinstance');
    } else {
      url.searchParams.set('searchinstance', instance);
    }
    window.history.replaceState({}, document.title, url.toString());
  }

  function focusSearchEditBox() {
    const searchBox = document.getElementById('search-box');
    searchBox.focus();  // focus the input box
    searchBox.select(); // selects all the text
  }

  const search_mode_init_text = "!!! mode !!!";
  const search_mode_global_text = "ðŸŒŽ&nbsp;All&nbsp;Pages";
  const search_mode_local_text = "â–¼&nbsp;Page";
  // is meant to be called once on init() to initialize.   keep that in mind.
  function toggleMode(forcemode=undefined) {
    const searchMode = document.getElementById('search-mode')
    if (forcemode) {
      searchMode.innerHTML = forcemode
    } else {
      if (searchMode.innerHTML == search_mode_init_text) {
        loadModePreference()
        searchMode.innerHTML = searchMode.innerHTML == search_mode_init_text ? search_mode_local_text : searchMode.innerHTML
      } else {
        searchMode.innerHTML = searchMode.innerHTML != search_mode_local_text ? search_mode_local_text : search_mode_global_text;
      }
    }
    saveModePreference();
    document.getElementById('mark-counter').style.display = searchMode.innerHTML == search_mode_local_text ? 'inline-block' : 'none' 
    document.getElementById('search-local-prev').style.display = searchMode.innerHTML == search_mode_local_text ? 'inline-block' : 'none' 
    document.getElementById('search-local-next').style.display = searchMode.innerHTML == search_mode_local_text ? 'inline-block' : 'none'
    document.getElementById('search-global-enter').style.display = searchMode.innerHTML == search_mode_global_text ? 'inline-block' : 'none'
    focusSearchEditBox()
  }

  // Add search control UI
  // Helper to clear marks
  function addSearchControl(term) {
    const controlDiv = document.getElementById('searchcontrol');
    if (!controlDiv) return;

    controlDiv.style.display = 'block';
    controlDiv.innerHTML = `
      <div class="search-inner" style="display: flex; justify-content: flex-end; align-items: center; gap: 0.3rem; width: 100%;">
        <button id="search-mode" style="width:auto; padding-left: 0.25rem; padding-right: 0.25rem;">!!! mode !!!</button>
        <input id="search-box" type="text" value="" autofocus>
        <span id="mark-counter">0/0</span>
        <button id="search-local-prev"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/keyboard_arrow_up_24dp_FFFFFF_FILL0_wght400_GRAD0_opsz24.svg"></button>
        <button id="search-local-next"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/keyboard_arrow_down_24dp_FFFFFF_FILL0_wght400_GRAD0_opsz24.svg"></button>
        <button id="search-global-enter" style="width:auto; padding-left: 0.25rem; padding-right: 0.25rem;">Search</button>
        <button id="search-clear" title="Clear search" style="font-weight: bold; font-size: 1.2rem; cursor: pointer;"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/close_small_24dp_FFFFFF_FILL0_wght400_GRAD0_opsz24.svg"></button>
      </div>
    `;

    document.getElementById('search-local-prev').addEventListener('click', prevMark);
    document.getElementById('search-local-next').addEventListener('click', nextMark);
    document.getElementById('search-global-enter').addEventListener('click', () => {
      const rawValue = document.getElementById('search-box').value;
      const searchterm = rawValue.trim();
      const encodedTerm = encodeURIComponent(searchterm);
      const newurl = `<%=SEARCH_URL%>${searchterm !== '' ? `?searchterm=${encodedTerm}` : ''}`
      console.log( newurl )
      window.location.href = newurl;
    });

    focusSearchEditBox();

    const searchBox = document.getElementById('search-box');
    searchBox.value = term; // may have quotes in term, e.g. dont set the DOM innerHTML attribute with `${term}`
    searchBox.addEventListener('input', () => {
      const newTerm = searchBox.value.trim();
      if (newTerm === '') {
        clearMarks();
        updateCounterDisplay();
      } else {
        markupSearchTerms(newTerm);
        currentIndex = 0;
        scrollToMark(0);
      }

      debouncedUpdateSearchTermInURL( newTerm )
    });

    // Clear (X) button logic
    document.getElementById('search-clear').addEventListener('click', () => {
      onCancel();
    });

    // mode toggle
    const searchMode = document.getElementById('search-mode')
    toggleMode(); // init mode
    searchMode.addEventListener('click', () => toggleMode() );
  }


  // start the search
  function onSearch() {
    // clean up if already up
    if (isSearching()) {
      onCancel( { clear_url: false } );
    }

    // invoke the search box
    const term = getSearchTermFromURL();
    if (term && term != '') markupSearchTerms(term);
    addSearchControl(term);
    if (term && term != '')
      requestAnimationFrame(() => scrollToMark(getSearchInstanceFromURL()));
  }

  // close the search
  function onCancel( options = { clear_url: true } ) {
    const searchBox = document.getElementById('search-box');
    const controlDiv = document.getElementById('searchcontrol');

    // Clear input box
    searchBox.value = '';
    
      // Clear marks
    clearMarks();
    // Update counter display
    updateCounterDisplay();
    // Remove searchterm from URL (no reload)
    if (options.clear_url)
      clearSearchTermFromURL();
    // Hide the search control bar if desired:
    controlDiv.style.display = 'none';
  }

  function getSelectedText() {
    let text = "";
    if (window.getSelection) {
      text = window.getSelection().toString();
      console.log( "getSelectedText:", text )
    } else if (document.selection && document.selection.type !== "Control") {
      // For old IE
      text = document.selection.createRange().text;
      console.log( "getSelectedText(IE):", text )
    }
    return text;
  }


  function applySearchStateFromURL() {
    const term = getSearchTermFromURL();
    if (term && term !== '') {
      search({ force: true });
      toggleMode(search_mode_local_text);
    } else {
      if (isSearching()) {
        onCancel({ clear_url: false });
      }
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    applySearchStateFromURL();
  });

  window.addEventListener('popstate', () => {
    applySearchStateFromURL();
  });

  document.addEventListener('keydown', (e) => {
    // page handler
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
      e.preventDefault();

      // if text is selected on the page, update the ?searchterm= queryparam
      const term = getSelectedText();
      if (term != "")
        updateSearchTermInURL(term)

      // pop up search box (it'll use whatever's in the ?searchterm= queryparam)
      search({ force: true });
    }

    // handler active only when searching
    if (isSearching() && e.key === 'Enter') {
      if (isSearchModeLocal())
        nextMark();
      else
        document.getElementById('search-global-enter').click();
    }

    // handler active only when searching
    if (isSearching() && e.key === 'Escape') {
      onCancel();
    }
  });

  // toggle the search dialog, options.force will force open/close
  function search(options = {}) {
    if (options.force == false) {
      onCancel();
      return;
    }
    if (options.force == true) {
      onSearch();
      return;
    }

    // toggle...
    if (isSearching()) {
      onCancel();
    } else {
      onSearch();
    }
  }
  /////////////////////////////////////////
</script>
