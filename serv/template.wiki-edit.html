
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title><%=TITLE%> - Editing <%=topic%> (markdown editor)</title>
  <%include "template.meta.html"%>
  <script>
    let module = { exports: {} }
    <%include "markdown.js"%>

    let isChanging = false; // Flag to indicate if the preview is currently changing
    let needsAnotherPreview = false; // Flag to indicate if another update is needed
    let lastMarkdownValue = ""; // Variable to track the last value
    let previewDebounceTimer;
    let undoManager = undefined;
    let applyFormat = undefined;
    let restoreSelection = undefined;
    let saveSelection = undefined;
    window.preventzoom = true;

    // update the textarea's selection using this, always...  (needed for restoration of selection after blur)
    function setSelection( start, end ) {
      const textarea = document.getElementById("markdown");
      textarea.selectionStart = start;
      textarea.selectionEnd = end;
      if (saveSelection)
        saveSelection();
    }

    // for autoscroll of the preview
    function createMirrorDiv(textarea, id = "markdown-mirror") {
      const div = document.createElement('div');
      document.body.appendChild(div);
      div.id = id

      const style = getComputedStyle(textarea);

      Object.assign(div.style, {
        position: 'absolute',
        whiteSpace: 'pre-wrap',
        wordWrap: 'break-word',
        visibility: 'hidden',
        zIndex: -1,
        overflow: 'auto',
        width: style.width,
        height: style.height,
        fontFamily: style.fontFamily,
        fontSize: style.fontSize,
        lineHeight: style.lineHeight,
        padding: style.padding,
        border: style.border,
        boxSizing: style.boxSizing,
      });

      return div;
    }

    // for autoscroll of the preview
    function updateMirrorContent(text, id = "markdown-mirror") {
      let mirrorDiv = document.getElementById("markdown-mirror")
      mirrorDiv.innerHTML = ''; // clear old content
      const lines = text.split('\n');
      for (const line of lines) {
        const span = document.createElement('span');
        span.textContent = line + '\n'; // keep line spacing
        mirrorDiv.appendChild(span);
      }
    }

    // for autoscroll of the preview
    function getFirstVisibleHeader(textarea, mirrorDiv) {
      const scrollTop = textarea.scrollTop;
      const spans = Array.from(mirrorDiv.childNodes);

      for (let i = 0; i < spans.length; i++) {
        const span = spans[i];
        //console.log( "span", span.offsetTop >= scrollTop, /^#+\s+.*$/.test(span.textContent), `"${span.textContent}"` )
        if (span.offsetTop >= scrollTop && /^#+\s+.*?\n?$/.test(span.textContent)) {
          return __sanitizeForHTMLParam( span.textContent.replace(/^#+\s+(.*?)\n?$/, "$1" ) );
        }
      }

      return null;
    }

    // for autoscroll of the preview
    let textarea_last_heading = ""
    function updateAutoScrollPreview() {
      const header = getFirstVisibleHeader(document.getElementById("markdown"), document.getElementById("markdown-mirror"));
      if (header != null && header != textarea_last_heading) {
        textarea_last_heading = header
        const anchor = document.getElementById(textarea_last_heading);
        console.log( "scroll to:", textarea_last_heading, anchor)
        if (anchor) {
          anchor.scrollIntoView({ behavior: 'smooth', block: 'start' });
        } else {
          console.log( "[ERROR] anchor not found in the DOM: ", textarea_last_heading )
        }
      }
    }

    function updatePreview() {
      try {
      if (isChanging) {
        needsAnotherPreview = true;
        return;
      }
      isChanging = true;

      function onFinishedChanging() {
        isChanging = false;
        if (needsAnotherPreview) {
          needsAnotherPreview = false;
          updatePreview(); // Trigger another preview update
        }
      }

      let markdown = document.getElementById("markdown").value;
      if (lastMarkdownValue === markdown) {
        onFinishedChanging()
        return
      }
      lastMarkdownValue = markdown
      let html = markdownToHtml( markdown, "<%=req_baseUrl%><%=view_route%>", { skipYouTubeEmbed: true } )
      // fetch("<%=req_baseUrl%>/preview", { method: "POST", headers: {"Content-Type": "application/json"}, body: JSON.stringify({ content: markdown,  }) })
      // .then(res => {
      //   // Check if the response is ok (status in the range 200-299)
      //   if (!res.ok) {
      //     throw new Error(`HTTP error! Status: ${res.status}`);
      //   }
      //   return res.text();
      // })
      // .then(html => {
        //requestIdleCallback(() => { // doesn't exist in safari!!!!!  defeats the purpose of trying to do this in a safe thread
        requestAnimationFrame(() => {
          updateMirrorContent(markdown);
          updateAutoScrollPreview();
          document.getElementById("preview").innerHTML = html;
          requestAnimationFrame(() => {
            onFinishedChanging(); // DOM updated AND painted
          });
        });

      // })
      // .catch(error => {
      //   isChanging = false;
      //   needsAnotherPreview = false;
      // });
      } catch (error) {
        console.log( error );
      }
    }

    function debounce(func, delay) {
      let timeoutId;
      return function(...args) {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          func.apply(this, args); // Call the function with the provided arguments
        }, delay);
      };
    }

    // Example of how to use debounce with updatePreview
    const debouncedUpdatePreview = debounce(updatePreview, 800);
    let markdown_version_on_server = <%=markdown_version%>;
    let markdown_version = <%=markdown_version%>;

    function status( message, color = "white", duration = 2000 ) {
      const status = document.getElementById("status");
      if (!status) return;

      status.textContent = message;
      status.style.color = color;

      status.classList.add("show");
      clearTimeout(status._timeout);

      status._timeout = setTimeout(() => {
        status.classList.remove("show");
      }, duration);
    }

    ////////////////////////// autosave into localStorage ////////////////
    const LS_KEY = `editor-autosave_<%=topic%>`;
    function autosaveMarkdownRestored() {
      const autosave_item = JSON.parse( localStorage.getItem(LS_KEY) ); // { content: "markdown goes here", version: N }
      //console.log( LS_KEY, autosave_item )
      if (autosave_item !== null) {
        markdown_version = autosave_item.version ? autosave_item.version : 0;
        document.getElementById('markdown').value = autosave_item.content ? autosave_item.content : autosave_item;
        status( `restored v${autosave_item.version}`, "#ffaa00", 5000 );
        setTimeout( () => {
          if (markdown_version < markdown_version_on_server) {
            undoManager.clear(); // can't restore saved undo history, when the text has changed (diffs wont line up)
            alert( `Your local autosave (${markdown_version}) appears out of date with the server version (${markdown_version_on_server}).\n - If you save, it will overwrite a newer version.\n - To be safe: Carefully copy/paste your markdown out to another app, and [cancel] here...` )
          }
        }, 1000)
        return true;
      }
      return false;
    }
    let autosaveLastSaved = ""
    function autosaveMarkdown() {
      const autosave_item = {
        content: document.getElementById('markdown').value,
        version: markdown_version // whatever was loaded in (from autosave, or from server)
      }

      // avoid setting if it didn't change.
      if (autosave_item.content === autosaveLastSaved) return
      autosaveLastSaved = autosave_item.content

      //console.log( LS_KEY, autosave_item )
      localStorage.setItem(LS_KEY, JSON.stringify( autosave_item ));
      status( 'autosaved...', "#aaff00", 1000 )
    }
    function autosaveMarkdownClear() {
      localStorage.removeItem(LS_KEY);
      status( '', "#ffffff", 0 );
    }
    const debouncedAutosaveMarkdown = debounce(autosaveMarkdown, 700);
    ////////////////////////// autosave into localStorage ////////////////


    function saveWiki() {
      let save_button = document.getElementById("save_button");
      save_button.disabled = true;                  // disable the button
      save_button.style.opacity = "0.5";            // grey it visually

      let markdown = document.getElementById("markdown").value;
      fetch("<%=req_baseUrl%>/save", {
        method: "PUT", 
        headers: {"Content-Type": "application/json"}, 
        body: JSON.stringify({ topic: "<%=topic%>", content: markdown, version: markdown_version }) 
      })
      .then( async res => {
        const data = await res.json();
        document.getElementById("preview").innerHTML = `<p>Msg:'${data.message}' Ver:'${data.version}'`

        if (res.status === 409) {
          alert( `v${data.version} - ${data.message}` );
          save_button.disabled = false;             // re-enable on error
          save_button.style.opacity = "1";          // restore visual
          return null
        }

        undoManager.clear();

        setTimeout( ()=> {
          autosaveMarkdownClear();
          window.location.href = "<%=req_baseUrl%><%=view_route%>/<%=topic%>";
        }, 700 )
      })
      .catch(error => {
        save_button.disabled = false;             // re-enable on error
        save_button.style.opacity = "1";          // restore visual
        document.getElementById("preview").innerHTML = `<p>Save Failed, Try again...  Error:'${error}'`
      })
    }

    function cancelWiki() {
      let cancel_button = document.getElementById("cancel_button");
      if (!cancel_button) alert( "wtf")
      cancel_button.disabled = true;                // disable button
      cancel_button.style.opacity = "0.5";          // grey it visually
      document.getElementById("preview").innerHTML = `<p>Discarding Changes`
      undoManager.clear();

      setTimeout( ()=> {
        autosaveMarkdownClear();
        window.location.href = '<%=req_baseUrl%>/view/<%=topic%>'
      }, 700 );
    }

    // Ensure updatePreview() runs once when the page loads
    document.addEventListener("DOMContentLoaded", async () => {
      document.getElementById('markdown').focus() // focus the textarea editor
      autosaveMarkdownRestored();

      debouncedUpdatePreview();

      const dropzone = document.getElementById("markdown");
      const uploadBtn = document.getElementById("uploadBtn");
      const uploadInput = document.getElementById("uploadInput");
      const dragHandle = document.querySelector('.drag-handle');
      const markdown = document.getElementById('markdown');
      const textarea = document.getElementById("markdown");
      const preview = document.getElementById('preview');


      uploadBtn.addEventListener("click", () => {
        uploadInput.click();
      });

      // handle the file selection
      uploadInput.addEventListener("change", handleFileSelect);

      // Handle image file drop
      dropzone.addEventListener("dragover", (event) => {
          event.preventDefault(); // Prevent default behavior to allow drop
      });

      dropzone.addEventListener("drop", (event) => {
          event.preventDefault();
          const file = event.dataTransfer.files[0]; // Get the first file
          handleFileSelect({ target: { files: [file] } });
      });

      const allowedTypes = ["image/*", "application/pdf", "audio/mpeg", "audio/mp4", "audio/m4a", "audio/x-m4a" ];
      document.getElementById('uploadInput').setAttribute('accept', allowedTypes.join(', ') );

      // General file upload handler, supporting images and PDFs
      async function handleFileUpload(file) {
        if (!file) {
          alert("No file selected.");
          return null;
        }

        const isAllowed = allowedTypes.some((type) => {
          const regex = new RegExp(`^${type.replace('*', '.+')}$`);
          return regex.test(file.type);
        });

        if (!isAllowed) {
          alert(`Please upload a file with type ${allowedTypes.join(', ')}.  Your file has ${file.type}`);
          return null;
        }

        const formData = new FormData();
        formData.append("file", file); // "file" is the field the backend will recieve

        try {
          const response =  file.type.startsWith("image/") ? await fetch("<%=req_baseUrl%>/upload/image", { method: "POST", body: formData }) :
                            await fetch("<%=req_baseUrl%>/upload/file", { method: "POST", body: formData });
          const data = await response.json();
          if (response.status === 415) {
            alert(`Upload failed: ${data.message || "Unsupported file type"}`);
            return null;
          }
          if (data.success) {
            return data.fileUrl; // let backend name it fileUrl, more general
          } else {
            alert(`Failed to upload file ${`with status ${response.status ? response.status : ""}`}`);
            return null;
          }
        } catch (error) {
          console.error("Error uploading file:", error);
          return null;
        }
      }

      function handleFileSelect(event) {
        const file = event.target.files[0];
        handleFileUpload(file).then((fileUrl) => {
          if (fileUrl) {
            setTimeout(() => {
              const textarea = document.getElementById("markdown");
              const start = textarea.selectionStart;
              const end = textarea.selectionEnd;
              const before = textarea.value.substring(0, start);
              const after = textarea.value.substring(end);

              let insertText;
              if (file.type.startsWith("image/")) {
                insertText = `![image](${fileUrl})`;
              } else if (file.type === "application/pdf") {
                insertText = `[PDF](${fileUrl})`;
              } else {
                insertText = `[file](${fileUrl})`;
              }

              // insert the new file link
              textarea.value = before + insertText + after;
              setSelection( start + insertText.length, start + insertText.length )
              undoManager.saveUndo( start, end, textarea.selectionStart, textarea.selectionEnd, true );  // call after change to textarea.value (and friends)

              //debouncedUpdatePreview();
              onMarkdownChanged();
            }, 400);
          }
        });
      }


      //////////////////////////   resize handle  //////////////////////////
      let isDragging = false;
      let initialXY = [0, 0];
      let initialFlex = { markdown: 50, preview: 50 };

      function beginResize(event) {
        isDragging = true;
        const point = event.touches ? event.touches[0] : event;
        initialXY = [point.clientX, point.clientY];

        const markdownBasis = parseFloat(getComputedStyle(markdown).flexBasis);
        const previewBasis = parseFloat(getComputedStyle(preview).flexBasis);
        initialFlex = { markdown: markdownBasis, preview: previewBasis };

        event.preventDefault();
      }


      function whileResize(event) {
        if (!isDragging) return;
        const point = event.touches ? event.touches[0] : event;

        const dx = point.clientX - initialXY[0];
        const dy = point.clientY - initialXY[1];

        const container = document.querySelector('.container');
        const isWide = (window.innerWidth / window.innerHeight) >= (3 / 2);

        if (isWide) {
          const containerWidth = container.clientWidth;
          const deltaPercent = (dx / containerWidth) * 100;
          const newPreview = initialFlex.preview + deltaPercent;
          const newMarkdown = 100 - newPreview;
          if (newPreview > 10 && newPreview < 90) {
            markdown.style.flexBasis = `${newMarkdown}%`;
            preview.style.flexBasis = `${newPreview}%`;
          }
        } else {
          const containerHeight = container.clientHeight;
          const deltaPercent = (dy / containerHeight) * 100;
          const newPreview = initialFlex.preview + deltaPercent;
          const newMarkdown = 100 - newPreview;
          if (newPreview > 10 && newPreview < 90) {
            markdown.style.flexBasis = `${newMarkdown}%`;
            preview.style.flexBasis = `${newPreview}%`;
          }
        }

        event.preventDefault(); // Prevent scroll during touch drag
      }

      function endResize() {
        isDragging = false;
        document.body.style.cursor = 'default';
      }

      document.addEventListener('mousemove', whileResize);
      document.addEventListener('mouseup', endResize);
      document.addEventListener('touchmove', whileResize, { passive: false });
      document.addEventListener('touchend', endResize);
      dragHandle.addEventListener('mousedown', beginResize);
      dragHandle.addEventListener('touchstart', beginResize, { passive: false });
      //////////////////////////   resize handle  //////////////////////////


      ////////////////////////// paste handler /////////////////////////////
      textarea.addEventListener("paste", async (event) => {
        try {
          event.preventDefault();

          // Get clipboard data
          const clipboardData = event.clipboardData || window.clipboardData;
          //console.log( "PASTE", clipboardData.types )

          // files / images.
          if (clipboardData.files && clipboardData.files.length > 0) {
            for (const file of clipboardData.files) {
              if (file.type.startsWith("image/")) {
                //console.log("Pasted image file:", file);

                // TODO: Replace this with your actual image upload logic
                const imageUrl = await handleFileUpload(file); // Returns a URL after upload

                if (imageUrl) {
                  const markdown = `![pasted image](${imageUrl})`;
                  insertMarkdown(markdown)
                }
              }
            }
            return;
          }

          // HTML
          const html = clipboardData.getData("text/html");
          const plainText = clipboardData.getData("text/plain");
          if (clipboardData.types.includes("text/html")) {
            console.log( html ) // debug DEBUG!
            const markdown = html != "" ? htmlToMarkdown(html) : plainText; // fallback if nothing in text/html
            insertMarkdown(markdown != "" ? markdown : plainText);          // fallback if htmlToMarkdown fails
          } else if (clipboardData.types.includes("text/plain")) {
            if (plainText.match( /^https?:\/\// ))
              handleUrlPaste( plainText )
            else
              insertMarkdown( plainText );
          } else if (clipboardData.types.includes("text/uri-list")) {
            const url = clipboardData.getData("text/uri-list")
            handleUrlPaste( url );
          } else {
            insertMarkdown( extractBestClipboardString( clipboardData ) )
          }

          function handleUrlPaste(pastedText) {
            pastedText = stripCurrentWikiView(pastedText);
            const selectionStart = textarea.selectionStart;
            const selectionEnd = textarea.selectionEnd;

            if (selectionStart !== selectionEnd) {
              // Text is selected, format as markdown link
              const selectedText = textarea.value.substring(selectionStart, selectionEnd);
              const markdown = `[${selectedText}](${pastedText})`;
              insertMarkdown(markdown);
            } else {
              // No text selected, paste plain URL
              insertMarkdown(pastedText);
            }
          }

          function insertMarkdown(markdown) {
            const start = textarea.selectionStart;
            const end   = textarea.selectionEnd;
            const textBefore = textarea.value.substring(0, start);
            const textAfter  = textarea.value.substring(end);

            // perform the change
            textarea.value = textBefore + markdown + textAfter;
            setSelection( start + markdown.length, start + markdown.length )
            undoManager.saveUndo(start, end, textarea.selectionStart, textarea.selectionEnd, true);  // call after change to textarea.value (and friends)
            onMarkdownChanged();
          }

          function extractBestClipboardString(clipboardData) {
            const data = Array.from(clipboardData.types)
              .sort((a, b) => a.startsWith('text/') === b.startsWith('text/') ? 0 : a.startsWith('text/') ? -1 : 1 )
              .filter(type => !type.startsWith('image/'))   // remove image types, they wont be strings.. :)
              .map(type => clipboardData.getData(type))
              .filter(data => typeof data === 'string' && data.trim() !== '');
            return data[0] || '';
          }

          function stripCurrentWikiView(url) {
            // matches: http(s)://<anyhost>.(<basedomain>|localhost)/wiki/(edit|view)/<TITLE>[?query]
            const BASE_DOMAIN = "<%=CANONICAL_URL_DOMAIN%>";
            console.log( "stripCurrentWikiView:", url )
            console.log( "BASE_DOMAIN:", BASE_DOMAIN )

            try {
              const u = new URL(url);

              const isHttp = (u.protocol === "http:" || u.protocol === "https:");
              const hostOk =
                u.hostname === "localhost" ||
                u.hostname.endsWith("." + BASE_DOMAIN.replace(/^[^\.]*./, ""));

              const m = u.pathname.match(/^\/wiki\/(edit|view)\/(.+)$/);

              if (!isHttp || !hostOk || !m) return url;

              const title = decodeURIComponent(m[2]); // everything after /wiki/(edit|view)/
              const result = u.search ? `${title}${u.search}` : title;
              return `[${result.replace(/\?.*$/, '')}](${result})`;
            } catch {
              return url;
            }
          }

        } catch (error) {
          console.log( "PASTE ERROR: ", error )
        }
      });
      ////////////////////////// paste handler /////////////////////////////

      ////////////////////////// UNDO MANAGER //////////////////////////////////
      class UndoManager {
        constructor(textarea, pageKey, options = {}) {
          this.textarea = textarea;
          this.pageKey = pageKey;
          this.maxHistory = options.maxHistory || 50;
          this.debounceTime = options.debounceTime || 300;

          this.undoStack = [];
          this.redoStack = [];
          this.lastValue = textarea.value;
          this.lastCursor = { start: textarea.selectionStart, end: textarea.selectionEnd };
          this.lastSaveTime = 0;
          this.debounceTimer = null;

          this.load();

          textarea.addEventListener("input", () => this.handleInput());
          textarea.addEventListener("keydown", (e) => this.handleKeydown(e));
        }

        handleKeydown(e) {
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
            e.preventDefault();
            e.shiftKey ? this.redo() : this.undo();
          }
        }

        handleInput() {
          this.saveUndo();
        }

        saveUndo(beforeStart = null, beforeEnd = null, afterStart = null, afterEnd = null, force = false) {
          const value = this.textarea.value;
          const start = afterStart ?? this.textarea.selectionStart;
          const end   = afterEnd   ?? this.textarea.selectionEnd;

          // Use explicit or last-known "before" cursor
          const selBeforeStart = beforeStart ?? (this.undoStack.length === 0 ? (this.textarea.selectionStart-1) : this.lastCursor.start);
          const selBeforeEnd   = beforeEnd   ?? (this.undoStack.length === 0 ? (this.textarea.selectionEnd-1) : this.lastCursor.end);

          const diff = this.computeDiff(this.lastValue, value, selBeforeStart, selBeforeEnd, start, end);
          if (!diff) return;

          const now = Date.now();
          const lastDiff = this.undoStack[this.undoStack.length - 1];

          if (!force && lastDiff && now - this.lastSaveTime < this.debounceTime) {
            lastDiff.start = Math.min(lastDiff.start, diff.start);
            lastDiff.end = Math.max(lastDiff.end, diff.end);
            lastDiff.inserted += diff.inserted;
            lastDiff.deleted += diff.deleted;
            lastDiff.selectionAfterStart = diff.selectionAfterStart;
            lastDiff.selectionAfterEnd = diff.selectionAfterEnd;
          } else {
            this.undoStack.push(diff);
          }

          this.lastSaveTime = now;
          this.redoStack = [];
          this.lastValue = value;
          this.lastCursor = { start, end };
          this.saveToLocalStorage();
        }


        undo() {
          if (this.undoStack.length === 0) {
            status( `no more undo!`, "#ffaa00", 5000 );
            return;
          }
          status( `undo[${this.undoStack.length}]`, "#ffaa00", 5000 );

          const diff = this.undoStack.pop();
          const cursor = {
            start: diff.selectionBeforeStart,
            end: diff.selectionBeforeEnd
          };
          this.applyDiff(diff, true);
          this.redoStack.push(diff);

          // Explicitly restore "before edit" cursor
          this.textarea.selectionStart = cursor.start;
          this.textarea.selectionEnd = cursor.end;
          console.log( "undo", this.textarea.selectionStart, this.textarea.selectionEnd )

          //console.log( diff )

          this.lastValue = this.textarea.value;
          this.lastCursor = { ...cursor };

          onMarkdownChanged(); // handle change
        }

        redo() {
          if (this.redoStack.length === 0) {
            status( `no more redo!`, "#ffaa00", 5000 );
            return;
          }
          status( `redo[${this.redoStack.length}]`, "#ffaa00", 5000 );

          const diff = this.redoStack.pop();
          this.applyDiff(diff, false);
          this.undoStack.push(diff);

          this.lastValue = this.textarea.value;
          this.lastCursor = {
            start: this.textarea.selectionStart,
            end: this.textarea.selectionEnd,
          };

          onMarkdownChanged(); // handle change
        }

        applyDiff(diff, isUndo) {
          const val = this.textarea.value;
          const start = diff.start;
          const inserted = diff.inserted || "";
          const deleted = diff.deleted || "";

          if (isUndo) {
            // remove inserted, insert deleted
            this.textarea.value = val.slice(0, start) + deleted + val.slice(start + inserted.length);
            // restore cursor to BEFORE state
            this.textarea.selectionStart = diff.selectionBeforeStart;
            this.textarea.selectionEnd = diff.selectionBeforeEnd;
          } else {
            // remove deleted, insert inserted
            this.textarea.value = val.slice(0, start) + inserted + val.slice(start + deleted.length);
            // restore cursor to AFTER state
            this.textarea.selectionStart = diff.selectionAfterStart;
            this.textarea.selectionEnd = diff.selectionAfterEnd;
          }
        }

        computeDiff(oldVal, newVal, oldStart, oldEnd, newStart, newEnd) {
          // find left boundary
          let left = 0;
          while (
            left < oldVal.length &&
            left < newVal.length &&
            oldVal[left] === newVal[left]
          ) {
            left++;
          }

          // find right boundary
          let oldRight = oldVal.length - 1;
          let newRight = newVal.length - 1;
          while (oldRight >= left && newRight >= left && oldVal[oldRight] === newVal[newRight]) {
            oldRight--;
            newRight--;
          }

          const deleted = oldVal.slice(left, oldRight + 1);
          const inserted = newVal.slice(left, newRight + 1);
          if (deleted === "" && inserted === "") return null;

          return {
            start: left,
            end: oldRight + 1,
            inserted,
            deleted,
            selectionBeforeStart: oldStart,
            selectionBeforeEnd: oldEnd,
            selectionAfterStart: newStart,
            selectionAfterEnd: newEnd,
          };
        }

        saveToLocalStorage() {
          try {
            const data = {
              undoStack: this.undoStack,
              redoStack: this.redoStack,
              stackPointer: this.stackPointer,
            };
            //console.log( JSON.stringify( data ))
            localStorage.setItem( `undo:${this.pageKey}`, JSON.stringify(data) );
          } catch (err) {
            console.warn("Unable to save undo history", err);
          }
        }

        load() {
          try {
            const data = JSON.parse(localStorage.getItem(`undo:${this.pageKey}`));
            if (data) {
              this.undoStack = data.undoStack || [];
              this.redoStack = data.redoStack || [];
              this.stackPointer = data.stackPointer || this.undoStack.length;
            }
          } catch (err) {
            console.warn("Unable to load undo history", err);
          }
        }

        clear() {
          localStorage.removeItem(`undo:${this.pageKey}`);
        }
      }

      undoManager = new UndoManager( document.getElementById("markdown"), "<%=topic%>" );
      ////////////////////////// UNDO MANAGER //////////////////////////////////

      ////////////////////////// KEYBOARD HANDLERS /////////////////////////////
      // formatting toggle (e.g. bold toggle (ctrl-b) to add/remove '**')
      function applyMarkdownFormatting( fmt = "**" ) {
        const fmt_len = fmt.length;

        let start = textarea.selectionStart;
        let end = textarea.selectionEnd;
        let value = textarea.value;

        // in the selected text
        // - trim whitespace from the selection before and after the selection (move the start++ if needed,  move the end-- if needed)
        // - trim anything after \n, since formatting can't go across newlines
        const original_selected_text = value.slice(start, end);
        const original_selected_text_leading_ws = (original_selected_text.match(/^[\s\n]+/) || [''])[0].length;
        const original_selected_text_trailing_was = (original_selected_text.match(/[\s]*\n[\s\S]*$|[\s\n]+$/) || [''])[0].length;
        start += original_selected_text_leading_ws;
        end -= original_selected_text_trailing_was;

        const before = value.slice(0, start);
        const selected = value.slice(start, end);
        const after = value.slice(end);

        // Case 3: selected text is "word" and there is outside **'s:  **word** — remove the **'s
        if (before.slice(-fmt_len) === fmt && after.slice(0, fmt_len) === fmt) {
          textarea.value = before.slice(0, -fmt_len) + selected + after.slice(fmt_len);
          setSelection( start - fmt_len, end - fmt_len )
          undoManager.saveUndo( start, end, textarea.selectionStart, textarea.selectionEnd, true );  // call after change to textarea.value (and friends)
          onMarkdownChanged();
          return;
        }

        // Case 2: selected text is "**word**": — remove the **'s
        if (selected.slice(0, fmt_len) === fmt && selected.slice(-fmt_len) === fmt) {
          textarea.value = before + selected.slice(fmt_len, selected.length - fmt_len) + after;
          setSelection( start, end - (fmt_len*2) )
          undoManager.saveUndo( start, end, textarea.selectionStart, textarea.selectionEnd, true );  // call after change to textarea.value (and friends)
          onMarkdownChanged();
          return;
        }

        // Case 1: add **
        textarea.value = before + fmt + selected + fmt + after;
        setSelection( start + fmt_len, end + fmt_len )
        undoManager.saveUndo( start, end, textarea.selectionStart, textarea.selectionEnd, true );  // call after change to textarea.value (and friends)
        onMarkdownChanged();
      }

      // apply any formatting to the active cursor position / selection
      applyFormat = ( options = {} ) => {
        if (options.key_bold) { status( "bold", "#ffffff", 2000 ); return applyMarkdownFormatting( '**' ); }
        if (options.key_italics) { status( "italics", "#ffffff", 2000 ); return applyMarkdownFormatting( '*' ); }
        if (options.key_underscore) { status( "underscore", "#ffffff", 2000 ); return applyMarkdownFormatting( '__' ); }
        if ((options.key_addtab || options.key_addindent || options.key_rmindent || options.key_help || options.key_togglebullet || options.key_link || options.key_addbullet || options.key_rmbullet)) {
          const value = textarea.value;
          let start = textarea.selectionStart;
          let end = textarea.selectionEnd;

          // Expand selection to full lines
          const before = value.lastIndexOf("\n", start - 1);
          const after = value.indexOf("\n", end);
          const lineStart = before === -1 ? 0 : before + 1;
          const lineEnd = after === -1 ? value.length : after;
          const selected = value.slice(lineStart, lineEnd);

          let modified;
          if (options.key_addindent) {
            status( "increment indentation", "#ffffff", 2000 ); 
            modified = selected.replace(/^/gm, "  ");
          }
          else if (options.key_rmindent) {
            status( "decrement indentation", "#ffffff", 2000 ); 
            modified = selected.replace(/^ {1,2}/gm, "");
          }
          else if (options.key_help) {
            status( "getting you some help", "#aaffaa", 2000 ); 
            const svgPopup = document.getElementById(`infopopup-popup`);
            if (svgPopup.style.display != "flex")
              svgPopup.style.display = 'flex'; // Show the popup
            else
              svgPopup.style.display = 'none'; // Hide the popup
            return;
          }
          else if (options.key_addbullet) {
            status( "add bullet(s)", "#ffffff", 2000 ); 
            modified = selected.replace(/^(\s*)(?:- )?/gm, "$1- ");
          }
          else if (options.key_rmbullet) {
            status( "remove bullet(s)", "#ffffff", 2000 ); 
            modified = selected.replace(/^(\s*)- /gm, "$1");
          }
          else if (options.key_togglebullet) {
            status( "toggle bullet(s)", "#ffffff", 2000 ); 
            modified = selected.replace(/^(\s*)(- )?/gm, (match, spaces, bullet) => {
              // If there’s already a bullet, remove it; otherwise, add one
              return spaces + (bullet ? "" : "- ");
            });
          }
          else if (options.key_addtab) {
            status( "indent", "#ffffff", 2000 ); 
            // there's no selection, just add 2 spaces at the cursor when user hits TAB
            const insert_chars = "  "
            const before = value.slice(0, start);
            const after = value.slice(end);
            textarea.value = before + insert_chars + after;
            setSelection( start + insert_chars.length, start + insert_chars.length )
            undoManager.saveUndo( start, end, textarea.selectionStart, textarea.selectionEnd, true );  // call after change to textarea.value (and friends)
            onMarkdownChanged();
            return;
          }
          else if (options.key_link) {
            status( "hyperlink", "#ffffff", 2000 ); 
            const selection = value.slice(start, end).trim();
            let insert_chars;
            if ((/^https?:\/\//i).test(selection)) {
              insert_chars = `[title](${selection})`;
            } else if (selection.length > 0) {
              insert_chars = `[${selection}](url)`;
            } else {
              insert_chars = `[title](url)`;
            }
            const before = value.slice(0, start);
            const after = value.slice(end);
            textarea.value = before + insert_chars + after;
            setSelection( start + insert_chars.length, start + insert_chars.length )
            undoManager.saveUndo(start, end, textarea.selectionStart, textarea.selectionEnd, true);
            onMarkdownChanged();
            return;
          }
          else {
            return; // allow normal typing for other keys
          }

          // Replace text
          const newValue = value.slice(0, lineStart) + modified + value.slice(lineEnd);
          textarea.value = newValue;
          setSelection( lineStart, lineStart + modified.length )
          undoManager.saveUndo( start, end, textarea.selectionStart, textarea.selectionEnd, true );  // call after change to textarea.value (and friends)
          onMarkdownChanged();
        }
      }

      // keyhandlers for indent and bullets
      document.getElementById('markdown').addEventListener('keydown', function (e) {
        const has_selection = textarea.selectionStart !== textarea.selectionEnd;
        const activeKeys = Object.fromEntries( Object.entries({
          key_addtab: e.key === "Tab" && !e.shiftKey && !has_selection,
          key_addindent: e.key === "Tab" && !e.shiftKey && has_selection,
          key_rmindent: e.key === "Tab" && e.shiftKey,
          key_togglebullet: (e.metaKey || e.ctrlKey) && e.key === "-" && !e.shiftKey,
          // key_addbullet: (e.metaKey || e.ctrlKey) && e.key === "-" && !e.shiftKey,
          // key_rmbullet: (e.metaKey || e.ctrlKey) && (e.key === "_" || e.key === "-") && e.shiftKey,
          key_bold: (e.metaKey || e.ctrlKey) && event.key.toLowerCase() === "b" && !e.shiftKey,
          key_italics: (e.metaKey || e.ctrlKey) && event.key.toLowerCase() === "i" && !e.shiftKey,
          key_underscore: (e.metaKey || e.ctrlKey) && event.key.toLowerCase() === "u" && !e.shiftKey,
          key_save: (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 's' && !e.shiftKey,
          key_link: (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'l' && !e.shiftKey,
          key_help: (event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'h' && !e.shiftKey,
        }).filter(([_, v]) => v) );
        const hasAnyActive = Object.values(activeKeys).some(Boolean);
        if (hasAnyActive) {
          e.preventDefault()
          applyFormat( activeKeys )
        }
        return false;
      });
      ////////////////////////// KEYBOARD HANDLERS /////////////////////////////

      ////////////////////////// SELECTION RESTORATION WHEN PRESSING A BUTTON //
      let cachedSelection = { start: 0, end: 0 };
      saveSelection = () => {
        cachedSelection.start = textarea.selectionStart;
        cachedSelection.end = textarea.selectionEnd;
      }
      ['select', 'keyup', 'mouseup'].forEach(ev =>
        textarea.addEventListener(ev, () => {
          if (document.activeElement !== textarea && textarea.selectionStart === 0 && textarea.selectionEnd === 0) {
            // Chrome just collapsed selection due to blur - ignore it!
            return;
          }
          saveSelection();
          // console.log( "addEventListener", cachedSelection.start, cachedSelection.end )
        })
      );
      document.querySelectorAll('.button2, .button1').forEach(btn => {
        btn.addEventListener('mousedown', () => {
          if (document.activeElement !== textarea && textarea.selectionStart === 0 && textarea.selectionEnd === 0) {
            // Chrome just collapsed selection due to blur - ignore it!
            return;
          }
          saveSelection();
          // console.log("mousedown:", cachedSelection.start, cachedSelection.end);
        });
      });

      // Call restoreSelection() before any function that uses textarea.selectionStart
      restoreSelection = () => {
        textarea.selectionStart = cachedSelection.start;
        textarea.selectionEnd = cachedSelection.end;
        // console.log( "restoreSelection", textarea.selectionStart, textarea.selectionEnd )
      }
      ////////////////////////// SELECTION RESTORATION WHEN PRESSING A BUTTON //

      ////////////////////////////////// AUTOSCROLL THE PREVIEW ////////////////////////////////////
      // Hook up everything  (to update:  updateMirrorContent(textarea.value))
      createMirrorDiv(textarea);
      textarea.addEventListener('scroll', () => {
        updateAutoScrollPreview();
      });
      ////////////////////////////////// AUTOSCROLL THE PREVIEW ////////////////////////////////////
    }); // DOMContentLoaded
  </script>
  <script>
    function createSvgPopup(id, title, content) {
      // Append CSS styles dynamically
      const style = document.createElement('style');
      style.textContent = `
        .svg-popup-container {
          position: relative;
          display: inline-block;
        }
        .svg-popup-container img.popup-trigger {
          width: 24px !important;
          height: 24px !important;
          flex-shrink: 0;       /* prevents shrinking in flexbox */
          display: inline-block; /* ensures width/height apply */
          max-width: none;       /* prevents parent max-width from overriding */
        }
        .svg-popup {
          display: none; /* Hidden by default */
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.8);
          justify-content: center;
          align-items: center;
          z-index: 1000;
        }
        .svg-popup-content {
          text-align: left;
          max-width: 95%;
          max-height: 80%;
          background-color: white;
          padding: 20px;
          border-radius: 10px;
          position: relative;
          overflow: auto; /* Allow scrolling if content overflows */
        }
        .svg-back-button {
          cursor: pointer;
          touch-action: manipulation;    /* Hint to prevent gesture-based zooming */
          position: absolute;
          top: 10px;
          left: 10px;
          width: 40px; /* Adjust size as needed */
          height: 40px;
        }
      `;
      document.head.appendChild(style);

      // Create the SVG Popup structure
      const container = document.createElement('div');
      container.classList.add('svg-popup-container');

      const svgImage = document.createElement('img');
      svgImage.src = '/<%=ASSETS_MAGIC%>/help_24dp_E3E3E3_FILL0_wght400_GRAD0_opsz24.svg'; // Replace with your SVG path
      svgImage.alt = 'Tap me';
      svgImage.classList.add('popup-trigger');
      svgImage.style.cursor = 'pointer';
      svgImage.style["touch-action"] = "manipulation";    /* Hint to prevent gesture-based zooming */
      svgImage.title="help (ctrl-h)" 

      //svgImage.style.width = '200px';
      //svgImage.style.height = 'auto';

      const svgPopup = document.createElement('div');
      svgPopup.classList.add('svg-popup');
      svgPopup.id = `${id}-popup`;

      const popupContent = document.createElement('div');
      popupContent.classList.add('svg-popup-content');

      const backButton = document.createElement('img');
      backButton.src = '/<%=ASSETS_MAGIC%>/arrow_back_ios_new_24dp_E3E3E3_FILL0_wght400_GRAD0_opsz24.svg'; // Replace with your back button SVG path
      backButton.alt = 'Back';
      backButton.classList.add('svg-back-button');
      backButton.id = `${id}-backButton`;

      const heading = document.createElement('h2');
      heading.style="text-align: right;";
      //heading.innerHTML = `<img src="${svgImage.src}" alt="[help]" title="[help]"/>${title}`;
      heading.innerHTML = `${title}`;

      const paragraph = document.createElement('p');
      paragraph.innerHTML = `
      ${content}
      `;

      // Append elements
      popupContent.appendChild(backButton);
      popupContent.appendChild(heading);
      popupContent.appendChild(paragraph);
      svgPopup.appendChild(popupContent);
      container.appendChild(svgImage);
      container.appendChild(svgPopup);
      document.getElementById(id).appendChild(container);

      // JavaScript functionality
      svgImage.addEventListener('click', () => {
        svgPopup.style.display = 'flex'; // Show the popup
      });

      backButton.addEventListener('click', () => {
        svgPopup.style.display = 'none'; // Hide the popup
      });

      // Optional: Close the popup when clicking outside the content area
      svgPopup.addEventListener('click', (event) => {
        if (event.target === svgPopup) {
            svgPopup.style.display = 'none'; // Hide the popup
        }
      });
    }

    function onMarkdownChanged() {
      debouncedUpdatePreview();
      debouncedAutosaveMarkdown();
    }
  </script>
  <style>
    <%include "style.css"%>
    body {
      background-color: #0D1116;
      color: #aaaaaa;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100dvh;
      font-size: 1rem;
      position: relative;
    }

    .container {
      display: flex;
      flex: 1;
      overflow: hidden;
      height: calc(100dvh - 0.625rem); /* Adjust for buttons-tray height */
    }

    /* Set initial flex-basis for resizing */
    #markdown, #preview {
      padding: 0.75rem;
      font-size: 1rem;
      border: 0.0625rem solid #ccc;
      border-radius: 0.375rem;
      box-shadow: 0.125rem 0.125rem .5rem rgba(0, 0, 0, 0.1);
      resize: none; /* Disable textarea resizing */
      overflow-y: auto;
      height: 100%; /* Ensure it takes full height of the container */
    }

    #preview {
      background-color: #ffffff;
    }
    #markdown { flex-basis: 50%; }
    #preview  { flex-basis: 50%; }

    /* Drag handle */
    .drag-handle {
      background-color: #ccc; /* Color of the handle */
      cursor: ew-resize; /* Cursor style */
      user-select: none; /* Prevent text selection */
      width: 0.625rem; /* Fixed width for handle */
    }

    
    .drag-handle {
      position: relative;
      z-index: 1;
    }

    /* give some extra collision area (non-visible) bounding the visible drag handle
       so the mouse/finger can more easily grab the drag handle */
    .drag-handle::before {
      content: '';
      position: absolute;
      top: -0.75rem;
      bottom: -0.75rem;
      left: -0.75rem;
      right: -0.75rem;
      cursor: ew-resize;
    }

    /* Media Queries */
    @media (max-aspect-ratio: 3/2) {
      .container {
        flex-direction: column; /* Stack vertically in portrait mode */
      }

      .drag-handle {
        width: 100%; /* Full width in portrait mode */
        height: 0.625rem; /* Height of the handle */
        cursor: ns-resize; /* Change cursor to indicate vertical resizing */
      }

      /* give some extra collision area (non-visible) bounding the visible drag handle
       so the mouse/finger can more easily grab the drag handle */
      .drag-handle::before {
        cursor: ns-resize;
      }

      #markdown, #preview {
        height: auto; /* Allow height to adjust */
      }
      #markdown { flex-basis: 90%; }
      #preview  { flex-basis: 10%; }
    }

    @media (min-aspect-ratio: 3/2) {
      .drag-handle {
        width: 0.625rem; /* Width of the handle */
        height: 100%; /* Full height in widescreen mode */
        cursor: ew-resize; /* Cursor style */
      }

      /* give some extra collision area (non-visible) bounding the visible drag handle
         so the mouse/finger can more easily grab the drag handle */
      .drag-handle::before {
        cursor: ew-resize;
      }
    }

    .buttons-tray {
      justify-content: flex-end;  /* <-- right-align children */
      text-align: right;
      padding: 0.75rem;
      background-color: #22282F;
      display: flex;
      align-items: center;
      /*gap: 0.4rem;*/ /* optional, adds consistent spacing between buttons */
    }


    .button1, .button2 {
      padding: 0.40rem 0.80rem;
      font-weight: 600;
      border-radius: 0.50rem;
      margin-left: .3em;
      cursor: pointer;
      touch-action: manipulation;    /* Hint to prevent gesture-based zooming */
    }

    .button1, .button2/*, #status*/ {
      font-size: 1.4rem;
    }

    /* Toast-style status popup */
    #status {
      position: fixed;
      bottom: 3.5rem; /* animation start:  1rem lower than final toast position in #status.show */
      left: 50%;
      transform: translateX(-50%);
      background: rgba(60, 60, 60, 0.9);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 500;
      text-align: center;
      white-space: nowrap;
      pointer-events: none; /* ignore mouse */
      opacity: 0;
      transition: opacity 0.3s ease, bottom 0.3s ease;
      z-index: 9999;
    }

    /* visible state when shown via JS */
    #status.show {
      opacity: 1;
      bottom: 4.5rem; /* animation end:  final toast position, right above footer;  1rem more than #status */
    }


    @media (orientation: portrait)  {
      .buttons-tray {
        padding-top: 1px;
        padding-bottom: 1px;
        padding-right: 1px;
      }
      .button1, .button2/*, #status*/ {
        font-size: 1rem;
        margin-left: .15em;
      }
      .drag-handle {
        height: 1.25rem; /* Height of the handle */
      }
      #status {
        bottom: 1.75rem; /* animation start:  1rem lower than final toast position in #status.show */
      }
      #status.show {
        opacity: 1;
        bottom: 2.75rem; /* animation end:  final toast position, right above footer;  1rem more than #status */
      }
    }

    .button1 {
      border: 0.0625em solid #3f944b;
      background-color: #228736;
      color: #ffffff;
    }

    .button1:hover {
      background-color: #228736;
      color: #F3F8F3;
    }

    .button2 {
      border: 0.0625em solid #7E8690;
      background-color: #22282F;
      color: #F3F8F3;
    }

    .button2:hover {
      color: #FFFFFF;
    }

    /* scrollable strip for formatting buttons */
    .format-buttons-scroll {
      display: flex;
      /* gap: 0.3em; */
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none; /* hide Firefox scrollbar */
      position: relative;
      padding: 0 0.5em;
      mask-image: linear-gradient(to right, transparent, black 1em, black calc(100% - 1em), transparent);
    }

    .format-buttons-scroll::-webkit-scrollbar {
      display: none; /* hide Chrome/Safari scrollbar */
    }

    /* gradient “scroll hint” edges */
    .format-buttons-scroll::before,
    .format-buttons-scroll::after {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1.5em;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .format-buttons-scroll::before {
      left: 0;
      background: linear-gradient(to right, #22282f, transparent);
    }

    .format-buttons-scroll::after {
      right: 0;
      background: linear-gradient(to left, #22282f, transparent);
    }

    /* Hide left or right gradient when fully scrolled */
    .format-buttons-scroll.scrolled-start::before { opacity: 0; }
    .format-buttons-scroll.scrolled-end::after   { opacity: 0; }
  </style>
</head>
<body>
  <!-- <h1>Markdown Editor: <%=topic%></h1> -->
  <div class="container">
    <div id="preview"></div>
    <div class="drag-handle"></div>
    <textarea id="markdown" class="markdown" onkeyup="onMarkdownChanged()" rows="10" cols="50"><%=markdown%></textarea>
  </div>
  <div id="status"><%=description%></div>
  <div class="buttons-tray">
    <!-- background-color: #333333; position:absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);  -->
    <div style="display: inline; font-size: 1.4rem;" id="infopopup"></div>
    <div id="format-buttons-scroll" class="format-buttons-scroll">
      <button id="uploadBtn" title="upload" class="button2">⇪</button>
      <button id="linkBtn" title="link (ctrl-l)" onclick="restoreSelection(); applyFormat( { key_link: true } )" class="button2">📎</button>
      <button id="toggle_bullet" title="toggle bullet (ctrl-dash)" class="button2" onclick="restoreSelection(); applyFormat( { key_togglebullet: true } )"><span style="display: inline-flex; align-items: center;"><span style="line-height: 1;">|</span><span style="line-height: 1; margin-left: 0.1em;">•</span></span></button>
      <button id="dec_indent" title="unindent selected text (shift-tab)" class="button2" onclick="restoreSelection(); applyFormat( { key_rmindent: true } )"><span style="display: inline-flex; align-items: center;"><span style="line-height: 1;">|</span><span style="line-height: 1; margin-left: 0.1em;">↞</span></span></button>
      <button id="inc_indent" title="indent selected text (tab)" class="button2" onclick="restoreSelection(); applyFormat( { key_addindent: true } )"><span style="display: inline-flex; align-items: center;"><span style="line-height: 1;">|</span><span style="line-height: 1; margin-left: 0.1em;">↠</span></span></button>
      <button id="apply_bold" title="bold selected text (ctrl-b)" class="button2" onclick="restoreSelection(); applyFormat( { key_bold: true } )"><b>B</b></button>
      <button id="apply_italics" title="italics selected text (ctrl-i)" class="button2" onclick="restoreSelection(); applyFormat( { key_italics: true } )"><i>I</i></button>
      <button id="apply_underscore" title="underscore selected text (ctrl-u)" class="button2" onclick="restoreSelection(); applyFormat( { key_underscore: true } )"><u>U</u></button>
      <button id="undo" title="undo last change (ctrl-z)" class="button2" onclick="restoreSelection(); undoManager.undo()">⤺</button>
      <button id="redo" title="redo last change (ctrl-shift-z)" class="button2" onclick="restoreSelection(); undoManager.redo()"><span style="display: inline-block; transform: scaleY(-1) translateY(1px);">⤻</span></button>
    </div>
    <script>
      const formatScroll = document.querySelector('.format-buttons-scroll');
      if (formatScroll) {
        function updateScrollShadows() {
          const maxScroll = formatScroll.scrollWidth - formatScroll.clientWidth;
          const x = formatScroll.scrollLeft;
          formatScroll.classList.toggle('scrolled-start', x <= 1);
          formatScroll.classList.toggle('scrolled-end',   x >= maxScroll - 1);
        }
        formatScroll.addEventListener('scroll', updateScrollShadows, { passive: true });
        window.addEventListener('resize', updateScrollShadows);
        updateScrollShadows();

        // make room when on tiny mobile screens...
        window.addEventListener('DOMContentLoaded', () => {
          function scrollButtonBarToRight() {
            formatScroll.scrollLeft = formatScroll.scrollWidth;
          }

          // Also run on window resize (for mobile orientation changes)
          function changeButtonTextToMakeRoom() {
            if (formatScroll.scrollWidth > formatScroll.clientWidth) {
              console.log( "brief" )
              document.getElementById("save_button").innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff"><path d="M382-208 122-468l90-90 170 170 366-366 90 90-456 456Z"/></svg>`//&#10003; ✔
              document.getElementById("cancel_button").innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff"><path d="m256-168-88-88 224-224-224-224 88-88 224 224 224-224 88 88-224 224 224 224-88 88-224-224-224 224Z"/></svg>`;//&#10005; ✖
              document.getElementById("rename_button").innerHTML = `<svg width="24" height="22" fill="#ffffff" version="1.1" viewBox="0 -960 960 880" xmlns="http://www.w3.org/2000/svg"><path d="m693.87-89.516-118.23-0.98646v-20.907c0-15.784 1.3782-21.436 5.6246-23.065 3.0935-1.1867 24.695-2.1584 48.004-2.1584h42.379v-768.07h-42.379c-23.309 0-44.911-0.97167-48.004-2.1584-4.2444-1.6289-5.6246-7.2772-5.6246-23.02v-20.862l238.25-1.9622-2e-3 24.002-2e-3 24.002h-96.008v768.07h96.008v24.891c0 13.69-0.40049 24.513-0.88834 24.052-0.48856-0.46097-54.093-1.2835-119.12-1.8259zm-692.64-147.55c-0.93673-2.4554-1.2902-131.68-0.78486-287.16l0.91926-282.69h618.72v572.49l-308.57 0.9085c-244.98 0.7217-308.93-0.0114-310.28-3.5558zm526.58-91.667c13.669-6.5235 27.604-16.661 35.438-25.78 18.422-21.443 35.666-59.849 43.024-95.824 6.0287-29.476 6.0414-32.587 0.2567-62.764-7.7001-40.168-16.116-59.123-36.138-81.392-22.513-25.04-47.929-36.427-81.078-36.326-28.574 0.0806-47.337 6.7598-70.424 25.045l-13.79 10.922-0.95958-77.583-0.95957-77.583-69.339-2.0347-0.75261 195.7c-0.41393 107.64-0.81443 204.1-0.88969 214.37l-0.13708 18.668h64.005l1.0254-12.445c1.876-22.757 3.476-23.591 18.018-9.3906 29.193 28.506 73.765 35 112.7 16.419zm-85.516-56.918c-7.8228-3.8151-19.424-12.819-25.78-20.008l-11.556-13.072v-118.27l13.334-12.775c31.692-30.363 67.876-34.733 90.653-10.949 18.853 19.687 25.415 41.424 25.546 84.621 0.10752 36.535-0.6088 40.684-10.48 60.45-13.188 26.407-28.181 37.281-51.128 37.082-9.0005-0.0806-22.765-3.2631-30.588-7.078zm-277.11 60.254c15.322-2.6683 28.586-8.0906 42.962-17.563l20.796-13.703 1.094 14.007 1.094 14.008 58.263 2.7e-4 -1.2794-109.31c-1.1518-98.411-1.9761-111.09-8.2676-127.12-11.081-28.24-32.858-46.992-66.395-57.17-21.692-6.5833-72.422-6.4501-101.38 0.2661-20.478 4.7492-55.612 17.584-55.567 20.3 0.04032 2.5272 16.961 42.292 18.762 44.092 1.1114 1.1114 14.454-2.3912 29.649-7.7832 20.459-7.2593 34.744-9.8812 55.044-10.103 25.545-0.27954 28.348 0.45157 41.089 10.705 9.8452 7.9227 15.428 16.385 19.937 30.222 3.4448 10.57 5.5725 21.018 4.7284 23.218-0.99855 2.6035-19.942 4.5921-54.267 5.6971-43.551 1.4017-56.138 3.0697-72.29 9.5796-24.066 9.6995-44.276 28.724-52 48.949-8.7314 22.862-5.4349 62.332 6.8283 81.758 12.101 19.169 30.812 33.247 51.646 38.856 21.133 5.6903 32.043 5.8919 59.557 1.1007zm-43.014-60.247c-8.7961-9.181-10.317-13.614-10.317-30.073 0-15.607 1.6785-21.103 8.7627-28.692 15.314-16.405 33.549-23.258 67.791-25.477l31.647-2.0502v28.963c0 28.143-0.35481 29.356-12.529 42.831-16.37 18.12-32.152 25.267-55.793 25.267-16.78 0-20.564-1.3785-29.56-10.768zm647.06 148.41c-0.99452-2.5911-1.3543-23.82-0.79965-47.174l1.008-42.463 94.23-1.9837v-383.62l-94.23-1.9837v-92.452h188.46v572.49l-93.43 0.94748c-74.95 0.76068-93.788 0.0134-95.238-3.7629z" stroke-width="13.44"/></svg>`;//&#10005; ✖
            } else {
              console.log( "verbose" )
              document.getElementById("save_button").innerHTML = "Save"
              document.getElementById("cancel_button").innerHTML = "Cancel"
              document.getElementById("rename_button").innerHTML = "Rename"
            }
          }
          changeButtonTextToMakeRoom();
          scrollButtonBarToRight();
          window.addEventListener("resize", changeButtonTextToMakeRoom);
          window.addEventListener("resize", scrollButtonBarToRight);
        })
      }
    </script>
    <script>
      createSvgPopup("infopopup", "Markdown Help", `<%include "template.markdown-help.html"%>`)
    </script>
    <button id="rename_button" title="rename page" class="button2" onclick="location.href='<%=req_baseUrl%>/rename/<%=topic%>'">Rename</button>
    <input type="file" id="uploadInput" accept="this will be populated later by javascript" style="display: none;">
    <button id="cancel_button" title="cancel editing" class="button2" onclick="cancelWiki()">Cancel</button>
    <button id="save_button" title="save edits" class="button1" onclick="saveWiki()">Save</button>
  </div>
  <%include "template.global-error-handler.html"%>
</body>
</html>
